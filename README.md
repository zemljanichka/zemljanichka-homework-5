# Морской бой (Пятая домашка)

**Данная домашка состоит из двух частей -- одна из них обязательна для всех, а вторая в случае выполнения даст вам бонусные баллы**

Сложная версия отличается только тем, что в ней необходимо реализовать бота, который должен в соревнованиях обойти
моего "туповатого" бота.

Все тесты разбиты на две группы -- **_Easy_** и **_Hard_**.

**_Easy_** проверяет корректность игры, и соблюдение формата для `human_player_t`.

**_Hard_** проверяет что вы смогли придумать достаточно умного бота, чтобы обыграть моего "туповатого" хотя бы в **90%** игр.

Если вы хотите выбрать простую версию домашки (по-умолчанию выбрана сложная версия), вам надо отредактировать файл
`CMakeLists.txt` согласно комментарию в первой его строке. **Но если выберете и сделаете сложную версию, то вы получите 5 доп баллов.**

## Что надо делать

Необходимо реализовать игру "Морской бой".

### Правила игры

#### Поле

Поле для игры в "Морской бой" представляет собой клетчатый квадрат размерами 10 на 10.

Строки занумерованым числами от 1 до 10, а столбцы латинскими буквами от 'A' до 'J'.

На поле расположено какое-то ненулевое количество кораблей

#### Корабль

N-палубным кораблем называют полоску из клеточек размерами 1 на N.

Корабли могут располагаться либо строго вертикально, либо строго горизонтально (параллельно осям координат), могут касаться краев поля, но других кораблей могут
касаться только уголками!

#### Флоу игры

У каждого игрока есть свое поле с расположенными на них кораблями. При этом игрок не видит где расположены корабли противника. Цель игры поразить все корабли
противника раньше него.

Во время хода игрок называет координаты (строка и столбец), обозначающие клеточку на вражеском поле куда "стреляет" игрок.

1) Если клеточка не является частью вражеского корабля, то противник кричит "Мимо!" и ход переходит к нему.
2) Если клеточка является частью вражеского корабля, то противник кричит "Попал!" и ход остается у стрелявшего игрока, пока игрок не "промахнется", после чего
   ход переходит к противнику (как описано в предыдущем пункте). Если "попадание" "унитожило" последнюю оставшуюся клетку какого-то вражеского корабля, то
   противник кричит "Убил!" и ход так же остается у стрелявшего игрока.

Игра заканчивается, когда все корабли какого-то игрока полностью
"уничтожены" и этот игрок объявляется "проигравшим", а другой "победителем".

### Архитектура кода

#### Поле

Поле это класс `field_t`, расположенный в файлах `game/field.h`
и `game/field.cpp`. Логику поля вам реализовывать не надо -- она реализована мной.

Что там есть:

1) Конструктор от числа -- генерит случайное поле на основе этого числа (поля созданные от одинаковых числел будут одинаковы), при этом на поле будут случайным
   правильным образом расположены 4 1-палубных кораблей, 3 2-палубных, 2 3-палубных и 1 4-палубный.
2) Конструктор от вектора строк -- чтобы задать контент поля вручную
3) `operator[]`, который возвращает ссылку (или константную ссылку)
   на строку поля с указанным индексом, поэтому вы можете использовать поле как двумерный массив (`f[i][j]` вернет вам ссылку на символ в `i`-ой строке и в `j`
   -ом столбце)
4) `operator<<` оператор вывода поля в поток вывода
5) Статичный метод `is_cell_valid`, которая проверяет, что переданные координаты `x` и `y` находятся внутри поля.
   (Напомню, что чтобы получить доступ к статичным полям или методам снаружи класса надо использовать имя класса и двойное двоеточие,
   например `field_t::is_cell_valid(x, y)`)
6) Статичная константа `FIELD_SIZE`, чтобы вы нигде в своем коде не использовали `10`, при пробегах по полю. Если у вас не получается использовать эту константу
   -- перечитайте предыдущий пункт
7) Статичные символьные константы, обозначающе чем заполняется поле в том или ином случае:
    * `EMPTY_CELL` '.' -- этим символом изначально заполнено все поле, кроме клеток где расположены клетки кораблей
    * `SHIP_CELL` '#' -- этим символом отмечены те клетки поля, в которых располагаются еще не "пораженные" клетки кораблей
    * `HIT_CELL` '*' -- этим символом отмечены "пораженные" клетки кораблей, иными словами, после "попадания" по клетки корбля она сменяется с `SHIP_CELL`
      на `HIT_CELL`
    * `MISS_CELL` '0' -- этим символом отмечены "пораженные" пустые клетки, иными словами, после "попадания" по пустой клетке они сменяется с `EMPTY_CELL`
      на `MISS_CELL`
8) Статичный константный массив длины 4 `DIRECTIONS`, с векторами направлений "вправо", "влево", "вниз", "вверх". Мб вам это понадобится

#### Игроки

Игроком называется класс, который отнаследован от интерфейса и реализует методы-рекации на события игры.

###### Интерфейс

Интерфейс располагается в файле `players/player-interface.h` и состоит из следующий методов:

1) `make_move` -- должен вернуть пару интов от `0` до `FIELD_SIZE - 1`
   -- ход текущего игрока на основе собственного поля и поля противника, переданных по константной ссылке, как аргументы этого метода
2) `on_incorrect_move` -- вызывается у игрока игрой, если он из `make_move` вернул координаты, которые не находятся на поле. Координаты передаются в метод как
   аргументы
3) `on_duplicate_move` -- вызывается у игрока игрой, если он из `make_move` вернул координаты, по которым игрок уже стрелял. Координаты передаются в метод как
   аргументы
4) `on_miss` -- вызывается у игрока игрой, если он
   "промахнулся", стреляя по координатам, которые вернул игрок из
   `make_move`. Координаты передаются в метод как аргументы
5) `on_hit` -- вызывается у игрока игрой, если он
   "попал" по кораблю портивника но не уничтожил его, стреляя по координатам, которые вернул игрок из `make_move`. Координаты передаются в метод как аргументы
6) `on_kill` -- вызывается у игрока игрой, если он
   "попал" по кораблю портивника и уничтожил его, стреляя по координатам, которые вернул игрок из `make_move`. Координаты передаются в метод как аргументы
7) `on_win` -- вызывается у игрока игрой, если он "уничтожил"
   все корабли противника и "победил"
8) `on_lose` -- вызывается у игрока игрой, если его противник
   "победил"

###### simple-ai-player

Пример простейшего бота для нашей игры, а также пример реализации интерфейса игрока. Расположен в файлах
`players/simple-ai-player.h` и `players/simple-ai-player.cpp`.

Этот бот просто стреляет в случайную клетку поля с тривиальной реализацией всех методов, кроме `make_move`.

Он также хранит в себе указатель на число, которое инкрементит на вызов `on_win`, если он не `nullptr`. В этом нет необходимости для бота, я добавил это, чтобы
подсчитать количество побед этого бота при проведении нескольких игр в рамках соревнований.

###### smart-ai-player

Бот, которого вы должны реализовать в рамках **_Hard_** версии.

Этот бот должен обыгрывать `simple-ai-player` в **90%** случаях. В соревновании будет проведено 1000 игр, и если этот бот выиграет хотя бы в 900 играх, то
считается, что вы справились с заданием.

Бот должен располагаться в файлах
`players/smart-ai-player.h` и `players/smart-ai-player.cpp`

###### human-player

Игрок, которого вы должны реализовать в рамках **_Easy_** и **_Hard_** версий.

Этот игрок нужен, чтобы вы сами могли поиграть в "Морской бой". Он получает информацию из потока ввода, а выдает информацию в поток вывода, тем самым может
коммуницировать с человеком через консоль. Но потоки ввода или вывода могут быть не только на консоль, это я буду использовать для проверки корректности вашей
реализации.

Для начала опишем _строковый формат координат_: координаты представляют собой одну строку из числа от 1 до 10 (номера строки)
и латинской буквы от 'A' до 'J' (номера столбца), например,
`1A`, `10J`, `5I`, `7B` и тп. Строки не в таком формате считаются некорректными.

Класс конструируется от ссылки на поток ввода (`input_stream`) и от ссылки на поток вывода (`output_stream`). Поток ввода -- это то, куда пользователь будет
вводить свои ходы для игры (бот будет их оттуда вычитывать), а поток вывода -- это то, куда бот будет писать информацию для пользователя о состоянии игры. Если
в качестве потока ввода передать `std::cin`, а в качестве потока вывода `std::cout`, то вы сможете поиграть, либо с другим человеком, либо с одним из ботов.

Что должен делать класс:

1) `make_move` -- должен добиться от пользователя ввода корректных координат в _строковом формате координат_. Сначала бот должен вывести поле текущего игрока,
   потом поле противника, а после ждать ввода координат в потоке ввода. Более формально:
    * В поток вывода вывести `Your field:`
    * В поток вывода вывести `std::endl`
    * В поток вывода вывести аргумент `my_field`
    * В поток вывода вывести `std::endl`
    * В поток вывода вывести `Enemy's field`
    * В поток вывода вывести `std::endl`
    * В поток вывода вывести аргумент `enemy_field`
    * В поток вывода вывести `std::endl`
    * В поток вывода вывести `Input you turn! [Example 1A or 10B or 6J]`
    * В поток вывода вывести `std::endl`
    * Считать из потока ввода одну строку (`std::getline(input_stream, s);`)
    * Проверить, что это строка является корректным _строковым форматом координат_ Если не является, то в поток вывода вывести
      `Incorrect move! [Correct example 1A or 10B or 6J]` и `std::endl`
      и перейти снова к предыдущему пункту, пока пользователь не введет корректный _строковый формат координат_. Когда пользователь справится ввести корректный
      _строковый формат координат_, получить из него пару чисел от `0` до `FIELD_SIZE - 1` и вернуть их из метода.
2) `on_incorrect_move` -- этот метод не должен быть вызван у этого бота, иными словами, вы должны добиться того, чтобы
   `make_move` всегда возвращал корректные координаты. Поэтому в качестве реализации можете просто сделать `assert(false);`
3) `on_duplicate_move` -- должен в поток вывода вывести информацию о том, что пользователь ввел координаты по которым уже стрелял в формате:
    * _Строковый формат координат-аргументов_ метода
    * Пробел
    * `DUPLICATE! Repeat move!`
    * Перевод строки `std::endl`
    * Например `4F DUPLICATE! Repeat move!`
4) `on_miss` -- должен в поток вывода вывести информацию о том, что пользователь "промахнулся" в формате:
    * _Строковый формат координат-аргументов_ метода
    * Пробел
    * `MISS! Enemy's turn!`
    * Перевод строки `std::endl`
    * Например `10I MISS! Enemy's turn!`
5) `on_hit` -- должен в поток вывода вывести информацию о том, что пользователь "попал" в формате:
    * _Строковый формат координат-аргументов_ метода
    * Пробел
    * `HIT! Your next move!`
    * Перевод строки `std::endl`
    * Например `7B HIT! Your next move!`
6) `on_kill` -- должен в поток вывода вывести информацию о том, что пользователь "убил" вражеский корабль в формате:
    * _Строковый формат координат-аргументов_ метода
    * Пробел
    * `KILL! Your next move!`
    * Перевод строки `std::endl`
    * Например `9E KILL! Your next move!`
7) `on_win` -- должен в поток вывода вывести информацию о том, что пользователь "победил" в формате:
    * `You WIN!`
    * Перевод строки `std::endl`
    * Например `You WIN!`
8) `on_lose` -- должен в поток вывода вывести информацию о том, что пользователь "проиграл" в формате:
    * `You LOSE!`
    * Перевод строки `std::endl`
    * Например `You LOSE!`

В тестах есть проверка, формата общения бота с миром, так что если вы где-то не соблюдете формат, то тесты упадут и вам скажут, что на "такой-то инпут ожидалось
то-то, а вы вывели это-то". Будьте аккуратны с переводами строк -- они тоже проверяются, так что если ваш вывод и ожидаемый вывод выглядят одинаковыми, то
скорее всего вы набагали с переводами строк. **ИСПОЛЬЗУЙТЕ ТОЛЬКО** `std::endl`

Если честно, я, конечно, ~~10~~ `FIELD_SIZE` раз перечитал описание формата, но я мог набагать в описании, так что если вы все сделаете по описанию, но тесты
будут падать по несоблюдению формата, то просто подгоните вывод под тесты :)

#### Игра

Второе, что надо реализовать в рамках и **_Easy_** и **_Hard_** версий -- это логика самой игры.

Класс для игры -- `sea_battle_t` должен находится в файлах `game/sea-battle.h` и `game/sea-battle.cpp`

Игра должна конструироваться от:

1) `shared_ptr` на первого игрока
2) Поля для первого игрока
3) `shared_ptr` на второго игрока
4) Поля для второго игрока

Вся логика игры должна быть реализована в методе `play()`:

1) Игра должна в бесконечном цикле запрашивать ходы от игроков и реагировать на них
2) Сначала текущим игроком яляется **первый** игрок
3) В начале каждой итерации цикла у текущего игрока должен быть вызван метод для получения координат для "выстрела". В качестве первого аргумента надо передать
   поле текущего игрока со всеми отметками, которые на нем оставили выстрелы противника. А в качестве второго аргумента надо передать поле противника текущего
   игрока, но не забудьте создать копию этого поля и затереть в копии все клетки, содержащие `SHIP_CELL`, чтобы не делать подсказок :). **Иными словами на этом
   поле должны остаться только пустые клетки, а так же следы от предыдущих выстрелов текущего игрока**
4) Если координаты не корректны, то надо вызвать у текущего игрока метод `on_incorrect_move` и передать в него эти координаты и перейти на следующую итерацию не
   меняя текушего игрока (мол, ты вернул какую-то фигню, давай ты попробуешь еще раз)
5) Если по этим координатам уже был "выстрел", то у текущего игрока надо вызывать метод `on_duplicate_move` и передать в него эти координаты и перейти на
   следующую итерацию, не меняя текущего игрока (мол ты "выстрелил" туда, куда уже "стрелял", давай ты попробуешь еще раз)
6) Если текущий игрок "попал" в пустую клетку, то надо на поле его противника пометить эту клетку как `MISS_CELL`, вызвать у текущего игрока метод `on_miss` и
   передать в него эти координаты и сменить текущего игрока на его противника, а потом перейти на следующую итерацию цикла.
7) Если текущий игрок "попал" в корабль противника, то надо на поле его противника пометить эту клетку как `HIT_CELL` и:
    * Если это была последняя "живая" клетка этого корабля, то надо вызвать у игрока **только** метод `on_kill` и передать в него эти координаты
    * В противном случае вызвать метод `on_hit` и передать в него эти координаты
8) Если текущий игрок "уничтожил" все корабли противника, то надо **сначала** у него вызвать метод `on_win`, а **потом** у противника вызвать метод `on_lose` и выйти из
   цикла и из метода `play()`
9) В коде не должно быть никаких звездочек решеточек и тп, используйте константы из `field_t`!!! При нарушении этого правила я буду ругаться!

Что еще есть в `sea_battle_t`:

1) `enum` `turn_t` который надо использовать, чтобы понимать чей сейчас ход.
2) Статичный метод `change_turn`, который принимает `turn_t` и возвращает `turn_t` для другого игрока
3) Статичный метод `get_player_name`, который по `turn_t` возвращает человеко-читаемое представление `turn_t`

## Что можно менять

Файлы с игрой `game/sea-battle.h` и `game/sea-battle.cpp`

Файлы с игроком для человека `players/human-player.h` и `players/human-player.cpp`

Файлы с умным ботом `players/smart-ai-player.h` и `players/smart-ai-player.cpp`

## Тестирование

Чтобы собрать и запустить тесты надо выполнить:

`python3 scripts/run-tests.py`

Для сложной версии соревнование достаточно нагруженное, так что вам не стоит забывать о скорости работы вашего "умного" бота, в частности, вам надо уложить
соревнование в **три четверти секунды (750мс)** (мой чуть более умный бот без особых оптимизаций укладывается в 420мс)

Чтобы запустить тесты с проверкой скорости надо выполнить:

`python3 scripts/run-tests.py -c Release`

Если вы хотите узнать сколько работает ваша программа, но ее рубят по таймауту, то вы можете запустить тесты с повышенным таймаутом (при этом таймаут в
тестирующей системе не изменится). Для этого вам надо:

`python3 scripts/run-tests.py -c Release --timeout 100000`

Если у вас падает какой-то конкретный тест и вы хотите запускать только его, то вы можете открыть файл в **CLion** `main-game.cpp` или `main-human.cpp`
или `main-competition.cpp` (смотря для какой части домашки вы хотите запустить тест). Найти этот тест в коде и нажать на зеленый треугольничек слева от
декларации теста. Единственный минус такого запуска в том, что не будут проверены таймауты.

Чтобы запускать только один тест с проверкой таймаута вам надо:

`python3 scripts/run-tests.py -c Release --filter CompetitionTest.MainTest`

(тут `CompetitionTest.MainTest` -- имя теста, который выхотите запустить)

Также можно добавить опицию `--timeout 100000` чтобы запустить на одном тесте с повышенным таймаутом
